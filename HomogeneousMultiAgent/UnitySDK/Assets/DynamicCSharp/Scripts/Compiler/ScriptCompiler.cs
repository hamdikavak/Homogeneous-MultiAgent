using System;
using System.IO;
using System.Reflection;
using System.Collections.Generic;

namespace DynamicCSharp.Compiler
{
    internal struct ScriptCompilerError
    {
        public string errorCode;
        public string errorText;
        public string fileName;
        public int line;
        public int column;
        public bool isWarning;
    }

    internal interface ICompiler
    {
        // Properties
        string OutputDirectory { get; set; }

        bool GenerateSymbols { get; set; }

        byte[] AssemblyData { get; }

        byte[] SymbolsData { get; }

        // Methods
        void AddReference(string reference);

        void AddReferences(IEnumerable<string> references);

        ScriptCompilerError[] CompileFiles(string[] source);

        ScriptCompilerError[] CompileSource(string[] source);
    }

    /// <summary>
    /// The <see cref="ScriptCompiler"/> is the main interface for interacting with the 'mcs' compiler module.
    /// Compile requests should be issued using this class.
    /// </summary>
    public sealed class ScriptCompiler
    {
        // Private
        private const string compilerModule = "DynamicCSharp.Compiler.McsMarshal";

        private static readonly object compilerLock = new object();
        private ICompiler compiler = null;
        private string[] warnings = new string[0];
        private string[] errors = new string[0];
        private byte[] assemblyData = null;
        private byte[] symbolsData = null;
        private volatile bool isCompiling = false;

        // Properties
        /// <summary>
        /// Get the <see cref="Type"/> of the compiler module that must be loaded dynamically. 
        /// </summary>
        public static Type CompilerType
        {
            get { return typeof(ScriptCompiler).Assembly.GetType(compilerModule); }
        }

        /// <summary>
        /// Get all warnings generated by the last compile.
        /// </summary>
        public string[] Warnings
        {
            get { return warnings; }
        }

        /// <summary>
        /// Returns true if there were any warnings generated by the last compile.
        /// </summary>
        public bool HasWarnings
        {
            get { return warnings.Length > 0; }
        }

        /// <summary>
        /// Get all errors generated by the last compile.
        /// </summary>
        public string[] Errors
        {
            get { return errors; }
        }

        /// <summary>
        /// Returns true if there were any errors generated by the last compile.
        /// </summary>
        public bool HasErrors
        {
            get { return errors.Length > 0; }
        }

        /// <summary>
        /// Get the file ocontents of the compiled assembly result.
        /// The byte data can be used directly by <see cref="Assembly.Load(byte[])"/>. 
        /// </summary>
        public byte[] AssemblyData
        {
            get { return assemblyData; }
        }

        /// <summary>
        /// Get the .mdb debug symbols image for the compiled assembly.
        /// This image will only be generated if 'debugMode' is enabled in the dynamic C# settings.
        /// </summary>
        public byte[] SymbolsData
        {
            get { return symbolsData; }
        }

        /// <summary>
        /// Returns true if this <see cref="ScriptCompiler"/> instance is currently compiling. 
        /// </summary>
        public bool IsCompiling
        {
            get { return isCompiling; }
        }

        // Constructor
        /// <summary>
        /// Create an instance of the <see cref="ScriptCompiler"/>.
        /// in order to initialize successfully, the 'mcs' compiler module must load sucessfully.
        /// If the compiler module is not installed then an exception will be thrown.
        /// </summary>
        /// <exception cref="ApplicationException">The compiler module is not installed or could not be loaded</exception>
        public ScriptCompiler()
        {
            // Get the compiler type
            Type type = CompilerType;

            // Make sure we found the compiler instance
            if (type == null)
                throw new ApplicationException("Failed to load the compiler service. Make sure you have installed the compiler package for runtime script compilation. See documentation for help");

            // Create our compiler
            compiler = (ICompiler)Activator.CreateInstance(type);

            // Pass the output directory
            if (compiler != null)
            {
                compiler.OutputDirectory = DynamicCSharp.Settings.compilerWorkingDirectory;
                compiler.GenerateSymbols = DynamicCSharp.Settings.debugMode;
            }
        }

        // Methods
        /// <summary>
        /// Helper method that prints all compiler warning messages to the Unity console.
        /// </summary>
        public void PrintWarnings()
        {
            foreach (string warning in warnings)
                UnityEngine.Debug.LogWarning(warning);
        }

        /// <summary>
        /// Helper method that prints all compiler error messages to the Unity console.
        /// </summary>
        public void PrintErrors()
        {
            foreach (string error in errors)
                UnityEngine.Debug.LogError(error);
        }

        /// <summary>
        /// Attempts to compile the specified C# source files.
        /// </summary>
        /// <param name="sourceFiles">An array of filenames to batch compile</param>
        /// <param name="extraReferences">Any additional assembly reference names</param>
        /// <returns>True if the compile was successful or false if there were one or more errors</returns>
        public bool CompileFiles(string[] sourceFiles, params string[] extraReferences)
        {
            // Set the compiling flag
            isCompiling = true;

            ResetCompiler();
            ScriptCompilerError[] compileResult = null;

            lock (compilerLock)
            {
                // Register references
                compiler.AddReferences(extraReferences);

                // Invoke the compiler
                compileResult = compiler.CompileFiles(sourceFiles);

                // Get assembly data
                assemblyData = compiler.AssemblyData;
                symbolsData = compiler.SymbolsData;
            }

            // Success flag
            bool successful = true;

            foreach (ScriptCompilerError err in compileResult)
            {
                if (err.isWarning == true)
                {
                    // Generate a warning
                    AddWarning(err.errorCode, err.errorText, err.fileName, err.line, err.column);
                }
                else
                {
                    // Set flag
                    successful = false;

                    // Generate an error
                    AddError(err.errorCode, err.errorText, err.fileName, err.line, err.column);
                }
            }

            // Check for success
            if (successful == false)
            {
                assemblyData = null;
                symbolsData = null;
            }

            // Set the compiling flag
            isCompiling = false;

            // Check for success
            return successful;
        }

        /// <summary>
        /// Attempts to compile the specified C# source content.
        /// </summary>
        /// <param name="sourceContent">The string source content array containing the C# source code</param>
        /// <param name="extraReferences">Any additional assembly reference names</param>
        /// <returns>True if the compile was successful or false if there were one or more errors</returns>
        public bool CompileSources(string[] sourceContent, params string[] extraReferences)
        {
            // Set the compiling flag
            isCompiling = true;

            ResetCompiler();
            ScriptCompilerError[] compileResult = null;

            lock (compilerLock)
            {
                // Register references
                compiler.AddReferences(extraReferences);

                // Invoke the compiler
                compileResult = compiler.CompileSource(sourceContent);

                // Get assembly data
                assemblyData = compiler.AssemblyData;
                symbolsData = compiler.SymbolsData;
            }
            
            // Success flag
            bool successful = true;

            foreach (ScriptCompilerError err in compileResult)
            {
                if (err.isWarning == true)
                {
                    // Generate a warning
                    AddWarning(err.errorCode, err.errorText, err.fileName, err.line, err.column);
                }
                else
                {
                    // Set flag
                    successful = false;

                    // Generate an error
                    AddError(err.errorCode, err.errorText, err.fileName, err.line, err.column);
                }
            }

            // Check for success
            if (successful == false)
            {
                assemblyData = null;
                symbolsData = null;
            }

            // Set the compiling flag
            isCompiling = false;

            // Check for success
            return successful;
        }

        /// <summary>
        /// Attempts to compile a number of C# script files asynchronously.
        /// The compile will take place on a background thread so that you can perform other tasks on the main thread.
        /// Depending upon settings, the code may be security verified before being loaded which may result in an exception being thrown.
        /// </summary>
        /// <param name="sourceFiles">An array of source files to compile</param>
        /// <param name="extraReferences">An array of assembly reference names or paths that will be referenced by the output assembly</param>
        /// <returns>A yieldable <see cref="AsyncCompileOperation"/> object which contains state information for the compile operation</returns>
        public AsyncCompileOperation CompileFilesAsync(string[] sourceFiles, params string[] extraReferences)
        {
            // Create the async object
            return new AsyncCompileOperation(this, () =>
            {
                // Compile the files - lock is called when the compiler is accessed
                return CompileFiles(sourceFiles, extraReferences);
            });
        }

        /// <summary>
        /// Attempts to compile a number of C# script files asynchronously.
        /// The compile will take place on a background thread so that you can perform other tasks on the main thread.
        /// Depending upon settings, the code may be security verified before being loaded which may result in an exception being thrown.
        /// </summary>
        /// <param name="sourceContent">An array of strings whose contents are valie C# source code</param>
        /// <param name="extraReferences">An array of assembly reference names or paths that will be referenced by the output assembly</param>
        /// <returns>A yieldable <see cref="AsyncCompileOperation"/> object which contains state information for the compile operation</returns>
        public AsyncCompileOperation CompileSourcesAsync(string[] sourceContent, params string[] extraReferences)
        {
            // Create the async object
            return new AsyncCompileOperation(this, () =>
            {
                // Compile the sources - lock is called when the compiler is accessed
                return CompileSources(sourceContent, extraReferences);
            });
        }

        private void AddWarning(string code, string message, string file, int line, int column)
        {
            // Create the string
            string msg = string.Format("[CS{0}]: {1} in {2} at [{3}, {4}]", code, message, file, line, column);

            // Check for null location
            if (line == -1 || column == -1)
                msg = string.Format("[CS{0}]: {1}", code, message);

            // Add element
            Array.Resize(ref warnings, warnings.Length + 1);

            // Add to back
            warnings[warnings.Length - 1] = msg;
        }

        private void AddError(string code, string message, string file, int line, int column)
        {
            // Create the string
            string msg = string.Format("[CS{0}]: {1} in {2} at [{3}, {4}]", code, message, file, line, column);

            // Check for null location
            if (line == -1 || column == -1)
                msg = string.Format("[CS{0}]: {1}", code, message);

            // Add element
            Array.Resize(ref errors, errors.Length + 1);

            // Add to back
            errors[errors.Length - 1] = msg;
        }

        private void ResetCompiler()
        {
            // Reset errors
            errors = new string[0];
            warnings = new string[0];
            assemblyData = null;
            symbolsData = null;
        }
    }
}
